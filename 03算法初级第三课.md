---
create by 千羽 2021-09-23 算法引出的思想非常重要！！
---

[TOC]

## 面试算法书籍

- 书名：《程序员代码面试指南—IT名企算法与数据结构题目最优解》
- 作者：左程云

## 题目一 ：用数组结构实现大小固定的队列和栈

```java
// 用数组结构实现大小固定的栈

package com.nateshao.basic_class_01;

/**
 * @date Created by 邵桐杰 on 2021/9/23 11:06
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 用数组结构实现大小固定的栈
 */
public class ArrayToStack {
    private int[] arr;
    private int size;

    /**
     * 初始化栈
     *
     * @param initSize
     */
    public ArrayToStack(int initSize) {
        if (initSize < 0) {                 // 给定的初始值 < 0，报错
            throw new IllegalArgumentException("The init size is less than 0!");
        }
        arr = new int[initSize];
        size = 0;
    }

    /**
     * 入栈
     *
     * @param obj
     */
    public void push(int obj) {
        if (size == arr.length) {   // size 等于数组长度（栈的大小），说明栈已满，不能入栈。
            throw new ArrayIndexOutOfBoundsException("The stack is full!");
        }
        arr[size++] = obj;
    }

    /**
     * 出栈
     */
    public int pop() {
        if (size == 0) {  // size 等于 0，说明栈空，不能出栈。
            throw new ArrayIndexOutOfBoundsException("The stack is empty!");
        }
        return arr[--size];
    }

    /**
     * 返回栈顶
     */
    public int peek() {
        if (size == 0) {  // size 等于 0，说明栈空，所以没有栈顶。
            throw new IndexOutOfBoundsException("The stack is empty!");
        }
        return arr[size - 1];
    }

}
```



```java
package com.nateshao.basic_class_01;

/**
 * @date Created by 邵桐杰 on 2021/9/23 11:58
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 用数组结构实现大小固定的队列
 */
public class ArrayToQueue {
    private int[] arr;
    private int size;
    private int start;
    private int end;

    /**
     * 初始化队列
     *
     * @param initSize
     */
    public ArrayToQueue(int initSize) {
        if (initSize < 0) { // 如果给定的值 < 0，报错
            throw new IllegalArgumentException("The init size is less than 0！");
        }
        arr = new int[initSize];
        size = 0;
        start = 0;
        end = 0;
    }

    /**
     * 进队列
     *
     * @param obj
     */
    public void EnQueue(int obj) {
        if (size == arr.length) { // 如果 size 等于队列长度，说明队列已满，不能进队列，报错。
            throw new IndexOutOfBoundsException("The queue is full！");
        }
        arr[start] = obj;
        start = start == arr.length ? 0 : start + 1;// start 如果等于队列长度，重新变为 0，否则 加 1。
        size++;// 队列中的元素数量减 1。
    }

    /**
     * 出队列
     *
     * @return
     */
    public int DeQueue() {
        if (size == 0) {        // 如果 size 等于 0 ，说明队列为空，不能出队列，报错
            throw new IndexOutOfBoundsException("The queue is empty！");
        }
        int temp = end;
        end = end == arr.length ? 0 : end + 1; // end 如果等于队列长度，重新变为 0，否则 加 1。
        return arr[temp];       // 队列中的元素数量减 1。

    }


}
```

## 题目二 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

【要求】

1. pop、push、getMin操作的时间复杂度都是 $O(1)$。
2. 设计的栈类型可以使用现成的栈结构。

**方法：**

1. 初始化两个栈。当data压入4时，min也跟着压入4。当data压入5时，min压入4。（min只能比data小或者相等。如果data比min大，压入min上一个的值。）

<img src="https://gitee.com/nateshao/images/raw/master/img/20210923220540.png" style="zoom:50%;" />

```java
package com.nateshao.basic_class_03;

import java.util.Stack;
/**
 * @date Created by 邵桐杰 on 2021/9/24 10:06
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description:
 * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。
 * 【要求】
 * 1. pop、push、getMin操作的时间复杂度都是 $O(1)$。
 * 2. 设计的栈类型可以使用现成的栈结构。
 *
 * 方法：1. 初始化两个栈。当data压入4时，min也跟着压入4。当data压入5时，min压入4。
 * （min只能比data小或者相等。如果data比min大，压入min上一个的值。）
 */
public class Code_02_GetMinStack {
	public static class MyStack1 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack1() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum <= this.getmin()) {
				this.stackMin.push(newNum);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			int value = this.stackData.pop();
			if (value == this.getmin()) {
				this.stackMin.pop();
			}
			return value;
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static void main(String[] args) {
		MyStack1 stack1 = new MyStack1();
		stack1.push(3);
		System.out.println(stack1.getmin());
		stack1.push(4);
		System.out.println(stack1.getmin());
		stack1.push(1);
		System.out.println(stack1.getmin());
		System.out.println(stack1.pop());
		System.out.println(stack1.getmin());

		System.out.println("=============");

		MyStack1 stack2 = new MyStack1();
		stack2.push(3);
		System.out.println(stack2.getmin());
		stack2.push(4);
		System.out.println(stack2.getmin());
		stack2.push(1);
		System.out.println(stack2.getmin());
		System.out.println(stack2.pop());
		System.out.println(stack2.getmin());
	}

}
```





## 问题三

如何仅用队列结构实现栈结构？ 

思路：

1. 初始化两个队列，队列Data和队列Help

2. 进入12345到队列Data，好了，要把5放出来。

3. 先将1234存入队列help，5留在队列data里。然后把5输出。

4. 要把4放出来。先把123放在队列Data里面。4留在队列help。然后把4放出去。

   

![](https://gitee.com/nateshao/images/raw/master/img/20210923222542.png)



如何仅用栈结构实现队列结构？

思路：

1. 初始化两个栈。栈push只进，栈pop只出。
2. 比如：12345存入栈push，然后倒序（要一次倒完）存入栈pop
3. 在将5输出。
4. 两个原则：（1）栈push倒出栈pop时，要一次性倒完，不能倒2个；（2）栈pop有数据时，栈push不能导入数据。否则会乱

![](https://gitee.com/nateshao/images/raw/master/img/20210923225010.png)



```java
package com.nateshao.basic_class_03;

public class Code_01_Array_To_Stack_Queue {

	public static class ArrayStack {
		private Integer[] arr;
		private Integer size;

		public ArrayStack(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
		}

		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[size - 1];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			arr[size++] = obj;
		}

		public Integer pop() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			return arr[--size];
		}
	}

	public static class ArrayQueue {
		private Integer[] arr;
		private Integer size;
		private Integer first;
		private Integer last;

		public ArrayQueue(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
			first = 0;
			last = 0;
		}

		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[first];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			size++;
			arr[last] = obj;
			last = last == arr.length - 1 ? 0 : last + 1;
		}

		public Integer poll() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			size--;
			int tmp = first;
			first = first == arr.length - 1 ? 0 : first + 1;
			return arr[tmp];
		}
	}

	public static void main(String[] args) {

	}

}
```



> 举一反三：图的优先遍历  （用栈实现）
>
> 如果仅用栈实现，如何实现图的深度优先遍历？
>
> 解决：用两个队列结构，拼出一个栈结构，再用栈结构实现图的有限遍历
>

## 题目四 猫狗队列 【题目】 宠物、狗和猫的类如下：

```java
猫狗队列 【题目】 宠物、狗和猫的类如下：
public class Pet {
    private String type;

    public Pet(String type) {
        this.type = type;
    }

    public String getPetType() {
        return this.type;
    }
}

public class Dog extends Pet {
    public Dog() {
        super("dog");
    }
}

public class Cat extends Pet {
    public Cat() {
        super("cat");
    }
}

实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的
实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列
的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照
进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实
例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是
否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog
类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。
```

## 题目五 转圈打印矩阵

 【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。 

例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 

打印结果为：1，2，3，4，8，12，16，15，14，13，9， 5，6，7，11， 10 

【要求】 额外空间复杂度为O(1)。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190812102202748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMzNzkw,size_16,color_FFFFFF,t_70#pic_center)

































