---
create by 千羽 2021-09-23 算法引出的思想非常重要！！
---

[TOC]

## 面试算法书籍

- 书名：《程序员代码面试指南—IT名企算法与数据结构题目最优解》
- 作者：左程云

## 题目一 ：用数组结构实现大小固定的队列和栈

```java
// 用数组结构实现大小固定的栈

package com.nateshao.basic_class_01;

/**
 * @date Created by 邵桐杰 on 2021/9/23 11:06
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 用数组结构实现大小固定的栈
 */
public class ArrayToStack {
    private int[] arr;
    private int size;

    /**
     * 初始化栈
     *
     * @param initSize
     */
    public ArrayToStack(int initSize) {
        if (initSize < 0) {                 // 给定的初始值 < 0，报错
            throw new IllegalArgumentException("The init size is less than 0!");
        }
        arr = new int[initSize];
        size = 0;
    }

    /**
     * 入栈
     *
     * @param obj
     */
    public void push(int obj) {
        if (size == arr.length) {   // size 等于数组长度（栈的大小），说明栈已满，不能入栈。
            throw new ArrayIndexOutOfBoundsException("The stack is full!");
        }
        arr[size++] = obj;
    }

    /**
     * 出栈
     */
    public int pop() {
        if (size == 0) {  // size 等于 0，说明栈空，不能出栈。
            throw new ArrayIndexOutOfBoundsException("The stack is empty!");
        }
        return arr[--size];
    }

    /**
     * 返回栈顶
     */
    public int peek() {
        if (size == 0) {  // size 等于 0，说明栈空，所以没有栈顶。
            throw new IndexOutOfBoundsException("The stack is empty!");
        }
        return arr[size - 1];
    }

}
```



```java
package com.nateshao.basic_class_01;

/**
 * @date Created by 邵桐杰 on 2021/9/23 11:58
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 用数组结构实现大小固定的队列
 */
public class ArrayToQueue {
    private int[] arr;
    private int size;
    private int start;
    private int end;

    /**
     * 初始化队列
     *
     * @param initSize
     */
    public ArrayToQueue(int initSize) {
        if (initSize < 0) { // 如果给定的值 < 0，报错
            throw new IllegalArgumentException("The init size is less than 0！");
        }
        arr = new int[initSize];
        size = 0;
        start = 0;
        end = 0;
    }

    /**
     * 进队列
     *
     * @param obj
     */
    public void EnQueue(int obj) {
        if (size == arr.length) { // 如果 size 等于队列长度，说明队列已满，不能进队列，报错。
            throw new IndexOutOfBoundsException("The queue is full！");
        }
        arr[start] = obj;
        start = start == arr.length ? 0 : start + 1;// start 如果等于队列长度，重新变为 0，否则 加 1。
        size++;// 队列中的元素数量减 1。
    }

    /**
     * 出队列
     *
     * @return
     */
    public int DeQueue() {
        if (size == 0) {        // 如果 size 等于 0 ，说明队列为空，不能出队列，报错
            throw new IndexOutOfBoundsException("The queue is empty！");
        }
        int temp = end;
        end = end == arr.length ? 0 : end + 1; // end 如果等于队列长度，重新变为 0，否则 加 1。
        return arr[temp];       // 队列中的元素数量减 1。

    }


}
```

## 题目二 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

【要求】

1. pop、push、getMin操作的时间复杂度都是 $O(1)$。
2. 设计的栈类型可以使用现成的栈结构。

**方法：**

1. 初始化两个栈。当data压入4时，min也跟着压入4。当data压入5时，min压入4。（min只能比data小或者相等。如果data比min大，压入min上一个的值。）

<img src="https://gitee.com/nateshao/images/raw/master/img/20210923220540.png" style="zoom:50%;" />

```java
package com.nateshao.basic_class_03;

import java.util.Stack;
/**
 * @date Created by 邵桐杰 on 2021/9/24 10:06
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description:
 * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。
 * 【要求】
 * 1. pop、push、getMin操作的时间复杂度都是 $O(1)$。
 * 2. 设计的栈类型可以使用现成的栈结构。
 *
 * 方法：1. 初始化两个栈。当data压入4时，min也跟着压入4。当data压入5时，min压入4。
 * （min只能比data小或者相等。如果data比min大，压入min上一个的值。）
 */
public class Code_02_GetMinStack {
	public static class MyStack1 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack1() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum <= this.getmin()) {
				this.stackMin.push(newNum);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			int value = this.stackData.pop();
			if (value == this.getmin()) {
				this.stackMin.pop();
			}
			return value;
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}

	public static void main(String[] args) {
		MyStack1 stack1 = new MyStack1();
		stack1.push(3);
		System.out.println(stack1.getmin());
		stack1.push(4);
		System.out.println(stack1.getmin());
		stack1.push(1);
		System.out.println(stack1.getmin());
		System.out.println(stack1.pop());
		System.out.println(stack1.getmin());

		System.out.println("=============");

		MyStack1 stack2 = new MyStack1();
		stack2.push(3);
		System.out.println(stack2.getmin());
		stack2.push(4);
		System.out.println(stack2.getmin());
		stack2.push(1);
		System.out.println(stack2.getmin());
		System.out.println(stack2.pop());
		System.out.println(stack2.getmin());
	}

}
```





## 问题三

如何仅用队列结构实现栈结构？ 

思路：

1. 初始化两个队列，队列Data和队列Help

2. 进入12345到队列Data，好了，要把5放出来。

3. 先将1234存入队列help，5留在队列data里。然后把5输出。

4. 要把4放出来。先把123放在队列Data里面。4留在队列help。然后把4放出去。

   

![](https://gitee.com/nateshao/images/raw/master/img/20210923222542.png)



如何仅用栈结构实现队列结构？

思路：

1. 初始化两个栈。栈push只进，栈pop只出。
2. 比如：12345存入栈push，然后倒序（要一次倒完）存入栈pop
3. 在将5输出。
4. 两个原则：（1）栈push倒出栈pop时，要一次性倒完，不能倒2个；（2）栈pop有数据时，栈push不能导入数据。否则会乱

![](https://gitee.com/nateshao/images/raw/master/img/20210923225010.png)



```java
package com.nateshao.basic_class_03;

public class Code_01_Array_To_Stack_Queue {

	public static class ArrayStack {
		private Integer[] arr;
		private Integer size;

		public ArrayStack(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
		}

		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[size - 1];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			arr[size++] = obj;
		}

		public Integer pop() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			return arr[--size];
		}
	}

	public static class ArrayQueue {
		private Integer[] arr;
		private Integer size;
		private Integer first;
		private Integer last;

		public ArrayQueue(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
			first = 0;
			last = 0;
		}

		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[first];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			size++;
			arr[last] = obj;
			last = last == arr.length - 1 ? 0 : last + 1;
		}

		public Integer poll() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			size--;
			int tmp = first;
			first = first == arr.length - 1 ? 0 : first + 1;
			return arr[tmp];
		}
	}

	public static void main(String[] args) {

	}

}
```



> 举一反三：图的优先遍历  （用栈实现）
>
> 如果仅用栈实现，如何实现图的深度优先遍历？
>
> 解决：用两个队列结构，拼出一个栈结构，再用栈结构实现图的有限遍历
>

## 题目四 猫狗队列 【题目】 宠物、狗和猫的类如下：

```java
猫狗队列 【题目】 宠物、狗和猫的类如下：
public class Pet {
    private String type;

    public Pet(String type) {
        this.type = type;
    }

    public String getPetType() {
        return this.type;
    }
}

public class Dog extends Pet {
    public Dog() {
        super("dog");
    }
}

public class Cat extends Pet {
    public Cat() {
        super("cat");
    }
}

实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的
实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列
的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照
进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实
例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是
否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog
类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。
```

## 题目五 转圈打印矩阵

 【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。 

例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 

打印结果为：1，2，3，4，8，12，16，15，14，13，9， 5，6，7，11， 10 

【要求】 额外空间复杂度为O(1)。

**思路：**

1. 左上角的行 = 右下角的行  （在同一行） 。 从左上角的行 到 右下角的行 一直加加 输出打印

2. 左上角的列 = 右下角的列  （在同一列）。  从左上角的列 到 右下角的列 一直加加 输出打印



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190812102202748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMzNzkw,size_16,color_FFFFFF,t_70#pic_center)

```java
package com.nateshao.basic_class_03;

/**
 * @date Created by 邵桐杰 on 2021/9/23 17:17
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 转圈打印矩阵
 * 【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。
 * 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
 * 打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11， 10
 * 【要求】 额外空间复杂度为O(1)。
 *
 * 旋转正方形矩阵
 * 【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成顺时针旋转90度的样子。
 * 【要求】 额外空间复杂度为O(1)。
 */
public class Code_06_PrintMatrixSpiralOrder {
	public static void main(String[] args) {
		int[][] matrix = {  { 1, 2, 3, 4 },
				{ 5, 6, 7, 8 },
				{ 9, 10, 11, 12 },
				{ 13, 14, 15, 16 } };
		spiralOrderPrint(matrix);

	}
	/**
	 * 转圈打印矩阵
	 * @param matrix  矩阵
	 */
	public static void spiralOrderPrint(int[][] matrix) {
		int tR = 0;
		int tC = 0;
		int dR = matrix.length - 1;
		int dC = matrix[0].length - 1;
		while (tR <= dR && tC <= dC) {
			printEdge(matrix, tR++, tC++, dR--, dC--);
		}
	}
	/**
	 * 顺时针旋转打印
	 * (a,b)左上角坐标
	 * (c,d)右下角坐标
	 *
	 * @param m			矩阵
	 * @param tR	矩阵左上角行
	 * @param tC	矩阵左上角列
	 * @param dR	矩阵右下角行
	 * @param dC	矩阵右下角列
	 */
	public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
		// 左上角的行 = 右下角的行  （在同一行）
		if (tR == dR) {
			for (int i = tC; i <= dC; i++) { // 从左上角的行 到 右下角的行 一直加加 输出打印
				System.out.print(m[tR][i] + " ");
			}
		// 左上角的列 = 右下角的列  （在同一列）
		} else if (tC == dC) {				//  从左上角的列 到 右下角的列 一直加加 输出打印
			for (int i = tR; i <= dR; i++) {
				System.out.print(m[i][tC] + " ");
			}
		} else {
			int curC = tC;
			int curR = tR;
			while (curC != dC) {
				System.out.print(m[tR][curC] + " ");
				curC++;
			}
			while (curR != dR) {
				System.out.print(m[curR][dC] + " ");
				curR++;
			}
			while (curC != tC) {
				System.out.print(m[dR][curC] + " ");
				curC--;
			}
			while (curR != tR) {
				System.out.print(m[curR][tC] + " ");
				curR--;
			}
		}
	}
}
```



## 题目六  旋转正方形矩阵 

【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 

【要求】 额外空间复杂度为O(1)。

![](https://gitee.com/nateshao/images/raw/master/img/20210927152123.png)



![](https://gitee.com/nateshao/images/raw/master/img/20210927152130.png)





```java
package com.nateshao.basic_class_03;

/**
 * @date Created by 邵桐杰 on 2021/9/18 20:03
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description:旋转正方形矩阵
 * 【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成
 * 顺时针旋转90度的样子。
 */
public class Code_05_RotateMatrix {
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4},
                          {5, 6, 7, 8},
                          {9, 10, 11, 12},
                          {13, 14, 15, 16}};
        printMatrix(matrix);
        rotate(matrix);
        System.out.println("=========");
        printMatrix(matrix);

    }

    public static void rotate(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = matrix.length - 1;
        int dC = matrix[0].length - 1;
        while (tR < dR) {
            rotateEdge(matrix, tR++, tC++, dR--, dC--);
        }
    }

    /**
     *
     * @param m
     * @param tR    左上角的行
     * @param tC    左上角的列
     * @param dR    右上角的行
     * @param dC    右上角的列
     *              正方形，四角角顺时针交换位置，然后下一位也是四个数交换
     */
    public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) {
        int times = dC - tC;
        int tmp = 0;
        for (int i = 0; i != times; i++) {
            tmp = m[tR][tC + i];
            // 四个点交换 （旋转90度）
            m[tR][tC + i] = m[dR - i][tC];
            m[dR - i][tC] = m[dR][dC - i];
            m[dR][dC - i] = m[tR + i][dC];
            m[tR + i][dC] = tmp;
        }
    }

    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i != matrix.length; i++) {
            for (int j = 0; j != matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```





##  题目七 “之”字形打印矩阵 

【题目】 给定一个矩阵matrix，按照“之”字形的方式打印这 个矩阵，

例如： 1 2 3 4 5 6 7 8 9 10 11 12 “之”字形打印的结果为：1，2，5，9，6，3，4，7，10，11，

思路：A点永远往右移动。B点永远往下移动，到最下了往右移动。

打印：一开始从对角线从上往下打印，然后从下往上打印。

![](https://gitee.com/nateshao/images/raw/master/img/20210927231824.png)

```java
package com.nateshao.basic_class_03;
/**
 * @date Created by 邵桐杰 on 2021/9/20 10:06
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: “之”字形打印矩阵
 * 【题目】 给定一个矩阵matrix，按照“之”字形的方式打印这 个矩阵，
 * 例如： 1 2 3 4 5 6 7 8 9 10 11 12
 * “之”字形打印的结果为：1，2，5，9，6，3，4，7，10，11，
 */
public class Code_08_ZigZagPrintMatrix {

	public static void printMatrixZigZag(int[][] matrix) {
		int tR = 0; // t点行坐标
		int tC = 0; // t点列坐标
		int dR = 0;	// d点行坐标
		int dC = 0; // d点列坐标
		int endR = matrix.length - 1;
		int endC = matrix[0].length - 1;
		boolean fromUp = false;
		while (tR != endR + 1) { // a点往下走完，到最后一个点
			printLevel(matrix, tR, tC, dR, dC, fromUp);
			tR = tC == endC ? tR + 1 : tR; // 如果是走到最后一列，我就往下走，否则，我不变
			tC = tC == endC ? tC : tC + 1;
			dC = dR == endR ? dC + 1 : dC; // 来到最后一行，就++,否则不变
			dR = dR == endR ? dR : dR + 1; // 到最后一行不变，否则增加
			fromUp = !fromUp; // 一开始从对角线从上往下打印，然后从下往上打印。
		}
		System.out.println();
	}

	/**
	 * 打印 ，左上角到右下角打印or右下角到左上角打印
	 * @param m
	 * @param tR
	 * @param tC
	 * @param dR
	 * @param dC
	 * @param f
	 */
	public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
			boolean f) {
		if (f) {
			while (tR != dR + 1) {
				System.out.print(m[tR++][tC--] + " ");
			}
		} else {
			while (dR != tR - 1) {
				System.out.print(m[dR--][dC++] + " ");
			}
		}
	}

	public static void main(String[] args) {
		int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };
		printMatrixZigZag(matrix);

	}
}
```

## 题目八 在行列都排好序的矩阵中找数

 【题目】 给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。

实现一个函数，判断K 是否在matrix中。 例如： 0 1 2 5 2 3 4 7 4 4 4 8 5 7 7 9 如果K为7，返回true；

如果K为6，返 回false。 【要求】 时间复杂度为O(N+M)，额外空间复杂度为O(1)。

![](https://gitee.com/nateshao/images/raw/master/img/20210928120625.png)



## 题目九 在行列都排好序的矩阵中找数

【题目】 给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。实现一个函数，判断K 是否在matrix中。

 例如： 0 1 2 5 2 3 4 7 4 4 4 8 5 7 7 9 如果K为7，返回true；如果K为6，返 回false。 

【要求】 时间复杂度为O(N+M)，额外空间复杂度为O(1)。

思路1：从右上或者左下开始找。从右上点开始，如果这个数比要找到K大，那么不用考虑左上点这一列的数，直接往左走。

​        如果左边的数比右上点这个数小，那么就往下走。

```java
public static boolean turnUpMatrixBykOne(int[][] matrix, int k){
        int row1 = 0;
        int col1 = matrix[0].length - 1;
 
        // 判断
        while (col1 > -1 && row1 < matrix.length) {
            System.out.println(matrix[row1][col1]);
            if(matrix[row1][col1] == k) {
                return true;
            }else if(matrix[row1][col1] < k) {
                row1++;
            }else if(matrix[row1][col1] > k) {
                col1--;
            }
        }
        return false;
    }
```

思路2： 从左下角开始找，如果左下角位置元素比k大，往上走，如果比k小，往右走。

```java
public static boolean turnUpMatrixBykTwo(int[][] matrix, int k){
        int row1 = matrix.length -1;
        int col1 = 0;
 
        // 判断
        while (row1 > -1 && col1 < matrix[0].length) {
            System.out.println(matrix[row1][col1]);
            if(matrix[row1][col1] == k) {
                return true;
            }else if(matrix[row1][col1] > k){
                row1--;
            }else if(matrix[row1][col1] < k) {
                col1++;
            }
        }
 
        // 循环判断
        return false;
    }
以上两种实现都可以，但是不能从左上或者右下开始找，这样无法进行排查行和列。
```

## 题目十 打印两个有序链表的公共部分

【题目】 给定两个有序链表的头指针head1和head2，打印两个 链表的公共部分。

```java
public class PrintCommonPart {
    /*
    解题思路：链表的公共部分，其实就是两个链表重合的地部分。重合的情况有好几种，
    1、完全重合。两个链表的首尾node都一样。
    2、部分重合。呈一字型，也就是某个链表的尾部与另一个链表的前半部分有重合。
    3、部分重合。呈Y字型，两个链表的尾部完全重合
    这道题很简单，因为有序，所以就比较大小，小的指针往后移动。直到发现有指针为空到达尾部。
     */
    class Node{
        public int value;
        public Node next;
        public Node(int  data){
            this.value = data;
        }
        public void printCommonPart(Node head1,Node head2){
            while (head1.next != null && head2.next != null){
                if(head1.value < head2.value){
                    head1 = head1.next;
                }else if(head1.value > head2.value){
                    head2 = head2.next;
                }else {
                    System.out.println(head1.value + " ");//打印公共部分
                    head1 = head1.next;
                    head2 = head2.next;
                }
            }
        }
    }
}
------------------------------------------------------------------------------
public static void printCommonPart(Node head1, Node head2) {
    if (head1 == null || head2 == null) return;
    while (head1 != null && head2 != null) {
    	if (head1.val == head2.val) {
            System.out.print(head1.val + " ");
            head1 = head1.next;
            head2 = head2.next;
        } else if (head1.val < head2.val) {
            head1 = head1.next;
        } else {
            head2 = head2.next;
        }
    }
}
```

## 题目十一  判断一个链表是否为回文结构

【题目】 给定一个链表的头节点head，请判断该链表是否为回 文结构。 例如： 1->2->1，返回true。 1->2->2->1，返回true。 15->6->15，返回true。 1->2->3，返回false。

 进阶： 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂 度达到O(1)。

```Java
思路1：栈。2：找到中点，对折。然后比较。3：快指针走两步，慢指针走一步，
* 1，找到中点，将中点后半部分逆序。
* 2，指针A从前往后移动，指针B从后往前移动。
* 3，移到中点，如果AB两边都相等，则返回true，else返回false。
* 4，最后将B遍的结构逆转回来
```

![](https://gitee.com/nateshao/images/raw/master/img/20211008215938.png)
