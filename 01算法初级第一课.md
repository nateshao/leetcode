---
create by 千羽 2021-09-15 算法引出的思想非常重要！！
---

[TOC]

> GitHub: https://github.com/nateshao/leetcode

<center>欢迎关注千羽的公众号</center>

![程序员千羽](https://gitee.com/nateshao/images/raw/master/img/20211021102040.jpg)

## 死磕算法系列

1. 算法这个不多说，相信大家都知道算法的重要性，对于程序员来说，算法好的人，写起代码来特别快（我们班有几位同学正是）。而且在遇到某个问题时，他想的到解决办法很多。
2. 在大厂面试，基本上一面就是算法，特别是某节，对算法的要求特别高！

当然，学算法是件相对枯燥的事情，不过，当你懂得算法这种思路之后，你会发现，**算法**真的是一个很神奇的东西。所以，千羽也会不断的学习`死磕算法系列`文章，和大家一起学习，一起进步。

## 认识时间复杂度

> 常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

**时间复杂度**为一个算法流程中，常数操作数量的指标。常用O （读作big O）来表示。具体来说，在常数操作数量的表达式中， 只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分 如果记为f(N)，那么时间复杂度为O(f(N))  

**评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。**

## 一个简单的理解时间复杂度的例子

一个简单的理解时间复杂度的例子

一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。

- 算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；

- 算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；
- 算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数；

三个流程，三种时间复杂度的表达...

如何分析好坏？

## 对数器的概念和使用

对数器的概念和使用  

1. 有一个你想要测的方法a， 
2. 实现一个绝对正确但是复杂度不好的方法b， 
3. 实现一个随机样本产生器 
4. 实现比对的方法 
5. 把方法a和方法b比对很多次来验证方法a是否正确。 
6. 如果有一个样本使得比对出错，打印样本分析是哪个方法出错 
7. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。



<h2><center>十大经典排序算法</center></h2>



|   算法   | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最优) |  空间复杂度  | 稳定性 |
| :------: | :--------------: | :--------------: | :--------------: | :----------: | :----: |
| 冒泡排序 |     $O(n2)$      |     $O(n2)$      |      $O(n)$      |    $O(1)$    |  稳定  |
| 选择排序 |     $O(n2)$      |     $O(n2)$      |     $O(n2)$      |    $O(1)$    | 不稳定 |
| 插入排序 |     $O(n2)$      |     $O(n2)$      |      $O(n)$      |    $O(1)$    |  稳定  |
| 希尔排序 |   $O(n^{1.3})$   |     $O(n2)$      |      $O(n)$      |    $O(1)$    | 不稳定 |
| 快速排序 |   $O(nlog^2n)$   |     $O(n^2)$     |   $O(nlog^2n)$   | $O(nlog^2n)$ | 不稳定 |
| 归并排序 |   $O(nlog^2n)$   |   $O(nlog^2n)$   |   $O(nlog^2n)$   |    $O(n)$    |  稳定  |
| 计数排序 |     $O(n+k)$     |     $O(n+k)$     |     $O(n+k)$     |   $O(n+k)$   |  稳定  |
| 基数排序 |     $O(n*k)$     |     $O(n*k)$     |     $O(n*k)$     |   $O(n+k)$   |  稳定  |
|  桶排序  |     $O(n2)$      |     $O(n*k)$     |      $O(n)$      |   $O(n+k)$   |  稳定  |
|  堆排序  |   $O(nlog^2n)$   |   $O(nlog^2n)$   |   $O(nlog^2n)$   |    $O(1)$    |  稳定  |



## 1. 冒泡排序

时间复杂度 $O(N^2)$，额外空间复杂度$O(1)$

> 冒泡排序（Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

思路：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。

![](https://gitee.com/zfhelo/img/raw/master/1592110929.gif)

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * @date Created by 邵桐杰 on 2021/9/15 20:03
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 冒泡排序
 */
public class Code_00_BubbleSort {

    public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int e = arr.length - 1; e > 0; e--) {
            for (int i = 0; i < e; i++) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                }
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    // 数组排序
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // 生成任意数组
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // 数组复制
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // 两数是否相等
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // 打印数组
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            bubbleSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        bubbleSort(arr);
        printArray(arr);
    }

}
```

## 例子四: 选择排序的细节讲解与复杂度分析

时间复杂度 $O(N^2)$，额外空间复杂度 $O(1)$
```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * @date Created by 邵桐杰 on 2021/9/18 20:03
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 选择排序
 */
public class Code_02_SelectionSort {

	public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) {
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	// for test
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			selectionSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		selectionSort(arr);
		printArray(arr);
	}

}
```


## 例子五: 插入排序的细节讲解与复杂度分析

时间复杂度 $O(N^2)$，额外空间复杂度 $O(1)$
```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * @date Created by 邵桐杰 on 2021/9/18 20:03
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 插入排序
 */
public class Code_01_InsertionSort {

    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                swap(arr, j, j + 1);
            }
        }
    }

    /**
     * 交换
     *
     * @param arr
     * @param i
     * @param j
     */
    public static void swap(int[] arr, int i, int j) {
//		arr[i] = arr[i] ^ arr[j];
//		arr[j] = arr[i] ^ arr[j];
//		arr[i] = arr[i] ^ arr[j];
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test

    /**
     * 生成任意的数组
     * @param maxSize
     * @param maxValue
     * @return
     */
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            insertionSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        insertionSort(arr);
        printArray(arr);
    }

}
```
## 例子六: 剖析递归行为和递归行为时间复杂度的估算

剖析递归行为和递归行为时间复杂度的估算 

一个递归行为的例子

master公式的使用

$T(N) = a*T(N/b) + O(N^d)$

1) log(b,a) > d -> 复杂度为 $O(N ^ log(b,a))$
2) log(b,a) = d -> 复杂度为 $O(N^d * logN)$
3) log(b,a) < d -> 复杂度为 $O(N^d)$

## 例子七: 归并排序的细节讲解与复杂度分析

时间复杂度$ O(N*logN)$，额外空间复杂度 $O(N)$

A数组：[4,6,9]          B数组： [3，2，1]    

先对数组A,B；数组A,B排好序 。定义一个新的数组C。比较A数组，小的放在前面。数组A排好序之后，将数组B复制到数组C

C数组：[1,2,3,4,6,9 ]

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * 归并排序
 */
public class Code_05_MergeSort {

	/**
	 * 如果数组的长度为空，或者是数组的长度为1。直接返回，不需要比较
	 * @param arr
	 */
	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	/**
	 * 这个范围上只有一个数，直接返回
	 * @param arr
	 * @param l
	 * @param r
	 */
	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
		int mid = l + ((r - l) >> 1); // L和R中点的位置 （L + R）/ 2
		mergeSort(arr, l, mid); // 左部分排序  T(n/2)
		mergeSort(arr, mid + 1, r); // 右部分排序 T(n/2)
		merge(arr, l, mid, r); // 左部分和右部分合并 O(n)
		// 总的时间复杂度：T(N) = 2T(n/2) + O(N)
	}

	public static void merge(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;// 数组l,左侧第一的最小值。
		int p2 = m + 1;// 右侧第一的最小值。
		while (p1 <= m && p2 <= r) { // p1 or p2 谁小取谁，放在新的数组，重新排序数组
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		/**
		 * p1,p2两个数，必有一个数越界
		 */
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i]; // 最后将数组拷贝到arr[i]
		}
	}

	// for test
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			mergeSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		mergeSort(arr);
		printArray(arr);
	}
}
```

![](https://gitee.com/nateshao/images/raw/master/img/20210916120016.png)

## 例子八:小和问题和逆序对问题

小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。

例子： [1,3,4,2,5] 

1左边比1小的数，没有； 

3左边比3小的数，1； 

4左边比4小的数，1、3； 

2左边比2小的数，1； 

5左边比5小的数，1、3、4、2； 

所以小和为 1+1+3+1+1+3+4+2=16

逆序对问题

在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序 对。





参考链接：https://zfhelo.gitee.io/2020/06/14/1











