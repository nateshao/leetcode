---
create by 千羽 2021-09-15 算法引出的思想非常重要！！
---

[TOC]

> GitHub: https://github.com/nateshao/leetcode

<center>欢迎关注千羽的公众号</center>

![程序员千羽](https://gitee.com/nateshao/images/raw/master/img/20211021102040.jpg)

## 死磕算法系列

1. 算法这个不多说，相信大家都知道算法的重要性，对于程序员来说，算法好的人，写起代码来特别快（我们班有几位同学正是）。而且在遇到某个问题时，他想的到解决办法很多。
2. 在大厂面试，基本上一面就是算法，特别是某节，对算法的要求特别高！

当然，学算法是件相对枯燥的事情，不过，当你懂得算法这种思路之后，你会发现，**算法**真的是一个很神奇的东西。所以，千羽也会不断的学习`死磕算法系列`文章，和大家一起学习，一起进步。

## 认识时间复杂度

> 常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

**时间复杂度**为一个算法流程中，常数操作数量的指标。常用O （读作big O）来表示。具体来说，在常数操作数量的表达式中， 只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分 如果记为f(N)，那么时间复杂度为O(f(N))  

**评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。**

## 一个简单的理解时间复杂度的例子

一个简单的理解时间复杂度的例子

一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。

- 算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；

- 算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；
- 算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数；

三个流程，三种时间复杂度的表达...

如何分析好坏？

## 对数器的概念和使用

对数器的概念和使用  

1. 有一个你想要测的方法a， 
2. 实现一个绝对正确但是复杂度不好的方法b， 
3. 实现一个随机样本产生器 
4. 实现比对的方法 
5. 把方法a和方法b比对很多次来验证方法a是否正确。 
6. 如果有一个样本使得比对出错，打印样本分析是哪个方法出错 
7. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

<h2><center>十大经典排序算法</center></h2>



|   算法   | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最优) |  空间复杂度  | 稳定性 |
| :------: | :--------------: | :--------------: | :--------------: | :----------: | :----: |
| 冒泡排序 |     $O(n2)$      |     $O(n2)$      |      $O(n)$      |    $O(1)$    |  稳定  |
| 选择排序 |     $O(n2)$      |     $O(n2)$      |     $O(n2)$      |    $O(1)$    | 不稳定 |
| 插入排序 |     $O(n2)$      |     $O(n2)$      |      $O(n)$      |    $O(1)$    |  稳定  |
| 希尔排序 |   $O(n^{1.3})$   |     $O(n2)$      |      $O(n)$      |    $O(1)$    | 不稳定 |
| 快速排序 |   $O(nlog^2n)$   |     $O(n^2)$     |   $O(nlog^2n)$   | $O(nlog^2n)$ | 不稳定 |
| 归并排序 |   $O(nlog^2n)$   |   $O(nlog^2n)$   |   $O(nlog^2n)$   |    $O(n)$    |  稳定  |
| 计数排序 |     $O(n+k)$     |     $O(n+k)$     |     $O(n+k)$     |   $O(n+k)$   |  稳定  |
| 基数排序 |     $O(n*k)$     |     $O(n*k)$     |     $O(n*k)$     |   $O(n+k)$   |  稳定  |
|  桶排序  |     $O(n2)$      |     $O(n*k)$     |      $O(n)$      |   $O(n+k)$   |  稳定  |
|  堆排序  |   $O(nlog^2n)$   |   $O(nlog^2n)$   |   $O(nlog^2n)$   |    $O(1)$    |  稳定  |



## 1. 冒泡排序

时间复杂度 $O(N^2)$，额外空间复杂度$O(1)$

> 冒泡排序（Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

**思路：**

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。

<img src="https://gitee.com/zfhelo/img/raw/master/1592110929.gif" style="zoom:200%;" />

```java
package com.nateshao.basic_01_ten_sort;

/**
 * @date Created by 邵桐杰 on 2021/10/29 16:52
 * @微信公众号 程序员千羽
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 原文链接 https://zfhelo.gitee.io/2020/06/14/1/
 */
public class Code_01_BubbleSortTest {
    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void bubbleSort(int[] arr) {
        if (arr == null && arr.length < 2) {
            return;
        }
        boolean isSwap;
        // 外层循环控制比较的轮数
        for (int i = 0; i < arr.length - 1; i++) {
            isSwap = false;
            // 内层循环进行相邻元素比较
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) { // 前面的数比后面的数大则交换
                    swap(arr, j, j + 1);
                    isSwap = true;
                }
            }

            if (!isSwap) {
                return; // 代码优化，如果一轮循环中没有进行交换元素则说明数组已经是有序的了
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 2. 插入排序

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**思路：**

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

<img src="https://gitee.com/zfhelo/img/raw/master/1592116078.gif" style="zoom:200%;" />

```java
package com.nateshao.basic_01_ten_sort;

/**
 * @date Created by 邵桐杰 on 2021/10/29 21:56
 * @微信公众号 程序员千羽
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description:
 */
public class Code_02_InsertionSortTest {
    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        insertionSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                swap(arr, j, j + 1);
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 3. 希尔排序

希尔排序是对**插入排序的改良**。

插入排序对已经基本有序的数组排序效率高，**但在移动元素时只能是相邻的两个元素交换希尔排序加了一个间隔使交换元素不限于相邻**。间隔逐渐缩小当缩小到1时数组已经基本有序。

**当间隔缩小时不会破坏大间隔的排序**



<img src="https://gitee.com/zfhelo/img/raw/master/1592124465.gif" style="zoom:200%;" />



```java
package com.nateshao.basic_01_ten_sort;

import java.util.Arrays;

/**
 * @date Created by 邵桐杰 on 2021/10/30 10:44
 * @微信公众号 程序员千羽
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 希尔排序
 */
public class Code_04_ShellSort {
    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        shellSort(arr);
        System.out.println(Arrays.toString(arr));
        shellSort1(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 希尔排序 针对有序序列在插入时采用交换法
     *
     * @param arr
     */
    public static void shellSort(int[] arr) {
        if (arr == null && arr.length < 2) {
            return;
        }
        //增量gap，并逐步缩小增量
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                while (j - gap >= 0 && arr[j] < arr[j - gap]) {
                    //插入排序采用交换法
                    swap(arr, j, j - gap);
                    j -= gap;
                }
            }
        }
    }

    /**
     * 希尔排序 针对有序序列在插入时采用移动法。
     *
     * @param arr
     */
    public static void shellSort1(int[] arr) {
        if (arr == null && arr.length < 2) {
            return;
        }
        //增量gap，并逐步缩小增量
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]) {
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        //移动法
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
            }
        }
    }

    public static void swap(int[] arr, int a, int b) {
        arr[a] = arr[a] + arr[b];
        arr[b] = arr[a] - arr[b];
        arr[a] = arr[a] - arr[b];

    }
}
```

## 4. 选择排序

时间复杂度 $O(N^2)$，额外空间复杂度 $O(1)$

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**思路：**

1. 寻找出数组中最小（大）的一个数
2. 将最小的数与当前遍历数组的首个元素交换
3. 缩小遍历数组范围重复前两步

<img src="https://gitee.com/zfhelo/img/raw/master/1592114887.gif" style="zoom:200%;" />

```java
package com.nateshao.basic_01_ten_sort;

/**
 * @date Created by 邵桐杰 on 2021/10/29 22:51
 * @微信公众号 程序员千羽
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 选择排序
 */
public class Code_03_SelectionSortTest {
    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        selectionSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void selectionSort(int[] arr) {
        int min;
        for (int i = 0; i < arr.length - 1; i++) {
            min = i; // 默认当前排序数组的第一个元素为最小值
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[min] > arr[j]) { // 发现一个更小的，更小最小值索引
                    min = j;
                }
            }

            if (i != min) {
                swap(arr, i, min);
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 5. 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**思路：**

1. 将左边第一个数做为基准值
2. 从右边向左遍历寻找出一个小于基准数的值，将其赋值给左边的位置
3. 从左边向右遍历寻找出一个小于基准数的值，将其赋值给右边的位置
4. 重复2，3 直到左右索引相遇
5. 将基准值放在相遇的这个坐标上
6. 递归基准值左右两边的子数组

```java
package com.nateshao.basic_01_ten_sort;

import java.util.Arrays;

/**
 * @date Created by 邵桐杰 on 2021/10/30 12:09
 * @微信公众号 程序员千羽
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 快速排序
 */
public class Code_05_QuickSort {
    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    private static void quickSort(int[] arr, int indexLeft, int indexRight) {
        if (indexLeft >= indexRight) {
            return;
        }
        int left = indexLeft;
        int right = indexRight;
        int key = arr[left];

        while (left < right) {
            // 右边
            while (right > left && arr[right] > key) {
                right--;
            }
            arr[left] = arr[right];
            // 左边
            while (left < right && arr[left] <= key) {
                left++;
            }
            arr[right] = arr[left];
        }

        // 基准归位
        arr[left] = key;
        quickSort(arr, indexLeft, left - 1);
        quickSort(arr, right + 1, indexRight);
    }
}
```

## 7. 归并排序

时间复杂度$ O(N*logN)$，额外空间复杂度 $O(N)$

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用**分治法**（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。

### 步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

比如：A数组：[4,6,9]          B数组： [3，2，1]    

先对数组A,B；数组A,B排好序 。定义一个新的数组C。比较A数组，小的放在前面。数组A排好序之后，将数组B复制到数组C

C数组：[1,2,3,4,6,9 ]

<img src="https://gitee.com/zfhelo/img/raw/master/1592128354.gif" style="zoom:200%;" />



















## 六: 剖析递归行为和递归行为时间复杂度的估算

剖析递归行为和递归行为时间复杂度的估算 

一个递归行为的例子

master公式的使用

$T(N) = a*T(N/b) + O(N^d)$

1) log(b,a) > d -> 复杂度为 $O(N ^ log(b,a))$
2) log(b,a) = d -> 复杂度为 $O(N^d * logN)$
3) log(b,a) < d -> 复杂度为 $O(N^d)$

## 例子七: 归并排序的细节讲解与复杂度分析

时间复杂度$ O(N*logN)$，额外空间复杂度 $O(N)$

A数组：[4,6,9]          B数组： [3，2，1]    

先对数组A,B；数组A,B排好序 。定义一个新的数组C。比较A数组，小的放在前面。数组A排好序之后，将数组B复制到数组C

C数组：[1,2,3,4,6,9 ]

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * 归并排序
 */
public class Code_05_MergeSort {

	/**
	 * 如果数组的长度为空，或者是数组的长度为1。直接返回，不需要比较
	 * @param arr
	 */
	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	/**
	 * 这个范围上只有一个数，直接返回
	 * @param arr
	 * @param l
	 * @param r
	 */
	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
		int mid = l + ((r - l) >> 1); // L和R中点的位置 （L + R）/ 2
		mergeSort(arr, l, mid); // 左部分排序  T(n/2)
		mergeSort(arr, mid + 1, r); // 右部分排序 T(n/2)
		merge(arr, l, mid, r); // 左部分和右部分合并 O(n)
		// 总的时间复杂度：T(N) = 2T(n/2) + O(N)
	}

	public static void merge(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;// 数组l,左侧第一的最小值。
		int p2 = m + 1;// 右侧第一的最小值。
		while (p1 <= m && p2 <= r) { // p1 or p2 谁小取谁，放在新的数组，重新排序数组
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		/**
		 * p1,p2两个数，必有一个数越界
		 */
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i]; // 最后将数组拷贝到arr[i]
		}
	}

	// for test
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			mergeSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		mergeSort(arr);
		printArray(arr);
	}
}
```

![](https://gitee.com/nateshao/images/raw/master/img/20210916120016.png)

## 例子八:小和问题和逆序对问题

小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。

例子： [1,3,4,2,5] 

1左边比1小的数，没有； 

3左边比3小的数，1； 

4左边比4小的数，1、3； 

2左边比2小的数，1； 

5左边比5小的数，1、3、4、2； 

所以小和为 1+1+3+1+1+3+4+2=16

逆序对问题

在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序 对。





参考链接：

1. 十大经典排序算法：https://zfhelo.gitee.io/2020/06/14/1

2. 希尔排序：https://www.cnblogs.com/chengxiao/p/6104371.html









