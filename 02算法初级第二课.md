---
create by 千羽 2021-09-18 算法引出的思想非常重要！！
---

[TOC]

## 面试算法书籍 

- 书名：《程序员代码面试指南—IT名企算法与数据结构题目最优解》
- 作者：左程云

## 问题一

给定一个数组`arr`，和一个数`num`，请把小于等于`num`的数放在数组的左边，大于`num`的数放在数组的右边。 

要求额外空间复杂度 $ O(1)$，时间复杂度 $ O(N)$

## 问题二（荷兰国旗问题）

给定一个数组`arr`，和一个数`num`。

请把小于`num`的数放在数组的左边，等于`num`的数放在数组的中间，大于num的数放在数组的 右边。 

要求额外空间复杂度 $O(1)$，时间复杂度 $O(N)$

```java
package com.nateshao.basic_class_01;
/**
 * @date Created by 邵桐杰 on 2021/9/18 16:35
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description:
 * 问题二（荷兰国旗问题）
 * 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。
 * 要求额外空间复杂度O(1)，时间复杂度O(N)
 */
public class Code_08_NetherlandsFlag {

    public static int[] partition(int[] arr, int l, int r, int num) {
        int less = l - 1;
        int more = r + 1;
        int cur = l;
        while (cur < more) {
            if (arr[cur] < num) {
                swap(arr, ++less, cur++);
            } else if (arr[cur] > num) {
                swap(arr, --more, cur);
            } else {
                cur++;  // cur == num
            }
        }
        return new int[]{less + 1, more - 1};
    }

    // 两数交换
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // 随机生成数组
    public static int[] generateArray() {
        int[] arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 3);
        }
        return arr;
    }

    // 打印数组
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] test = generateArray();
        printArray(test);
        int[] res = partition(test, 0, test.length - 1, 1);
        printArray(test);
        System.out.println(res[0]);
        System.out.println(res[1]);
    }
}
```

随机快速排序的细节和复杂度分析 

可以用荷兰国旗问题来改进快速排序 时间复杂度 $O(N*logN)$，

额外空间复杂度$ O(logN)$

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
/**
 * @date Created by 邵桐杰 on 2021/9/18 20:03
 * @微信公众号 千羽的编程时光
 * @个人网站 www.nateshao.cn
 * @博客 https://nateshao.gitee.io
 * @GitHub https://github.com/nateshao
 * @Gitee https://gitee.com/nateshao
 * Description: 快速排序
 */
public class Code_04_QuickSort {

	public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}

	public static void quickSort(int[] arr, int l, int r) {
		if (l < r) {
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r); // 随机快排
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

	public static int[] partition(int[] arr, int l, int r) {
		int less = l - 1;
		int more = r;
		while (l < more) {
			if (arr[l] < arr[r]) {
				swap(arr, ++less, l++);
			} else if (arr[l] > arr[r]) {
				swap(arr, --more, l);
			} else {
				l++;
			}
		}
		swap(arr, more, r);
		return new int[] { less + 1, more };
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	// for test
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			quickSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		quickSort(arr);
		printArray(arr);

	}
}
```

实际上，工程上是快排是采用非递归的方式。所以一切递归行为都可以改成快排。

## 堆排序

时间复杂度$O(N*logN)$，额外空间复杂度$O(1) $

![](https://gitee.com/nateshao/images/raw/master/img/20210921082735.png)



求左子树：$2*i + 1$

求右子树：$2*i+2$

求父节点：$\frac{i-1}{2}$ 。0的父节点是他自己。

堆结构非常重要   堆（就是完全二叉树）

1. 堆结构的`heapInsert`与`heapify`
2. 堆结构的增大和减少 
3. 如果只是建立堆的过程，时间复杂度为$O(N) $
4. 优先级队列结构，就是堆结构



**大根堆的减堆顶操作**。将堆顶与堆底交换，数组减少长度1，踢出堆顶。最后堆底在堆顶重新调整成大根堆。

**大根堆有序输出**：将堆顶与堆底交换，数组减少长度1，踢出堆顶。重新调整大根堆。重复上一步操作。

## 排序算法的稳定性及其汇总

1. 问题：为什么在数据量小的时候，选择复杂度高的排序。因为常数项低。
2. 为什么在基础排序用快排，你自己定义的用归并排序呢？从稳定性出发。

## 有关排序问题的补充

1. 归并排序的额外空间复杂度可以变成$O(1)$，但是非常难，不 需要掌握，可以搜“归并排序 内部缓存法” 
2. 快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜“01 stable sort” 
3. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还 要求原始的相对次序不变，碰到这个问题，可以怼面试官。面试 官非良人。



## 技巧

> 所以，如果在面试中，面试官问的问题，自己也不会的话，可以举报。
>
> 什么情况下呢。第一：阴阳怪气。第二点，如果遇到有情绪化的面试官，大胆举报。自己准备的问题，自己没准备好答案。

面试场上，只有一句话是真的，面对面试官，投其所好，让面试官喜欢你。

用你想问题的方式，想问题的思路。。你的思维

## 比较器

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;
import java.util.Comparator;

/**
 * 比较器
 */
public class Code_09_Comparator {

	public static class Student {
		public String name;
		public int id;
		public int age;

		public Student(String name, int id, int age) {
			this.name = name;
			this.id = id;
			this.age = age;
		}
	}

	/**
	 * id 升序
	 */
	public static class IdAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.id - o2.id;
		}

	}

	/**
	 * id 降序
	 */
	public static class IdDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.id - o1.id;
		}

	}

	/**
	 * 年龄升序
	 */
	public static class AgeAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.age - o2.age;
//			if (o1.id<o2.id){
//				return -1;
//			}else if (o1.id>o2.id){
//				return 1;
//			}else {
//				return 0;
//			}
		}

	}

	/**
	 * 年龄降序
	 */
	public static class AgeDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.age - o1.age;
		}

	}

	public static void printStudents(Student[] students) {
		for (Student student : students) {
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
		System.out.println("===========================");
	}

	public static void main(String[] args) {
		Student student1 = new Student("A", 1, 23);
		Student student2 = new Student("B", 2, 21);
		Student student3 = new Student("C", 3, 22);

		Student[] students = new Student[] { student3, student2, student1 };
		printStudents(students);// CBA

		Arrays.sort(students, new IdAscendingComparator());
		printStudents(students);// ID: 123

		Arrays.sort(students, new IdDescendingComparator());
		printStudents(students);

		Arrays.sort(students, new AgeAscendingComparator());
		printStudents(students);

		Arrays.sort(students, new AgeDescendingComparator());
		printStudents(students);

	}
}
---------------------------------------------------------------
Name : C, Id : 3, Age : 22
Name : B, Id : 2, Age : 21
Name : A, Id : 1, Age : 23
===========================
Name : A, Id : 1, Age : 23
Name : B, Id : 2, Age : 21
Name : C, Id : 3, Age : 22
===========================
Name : C, Id : 3, Age : 22
Name : B, Id : 2, Age : 21
Name : A, Id : 1, Age : 23
===========================
Name : B, Id : 2, Age : 21
Name : C, Id : 3, Age : 22
Name : A, Id : 1, Age : 23
===========================
Name : A, Id : 1, Age : 23
Name : C, Id : 3, Age : 22
Name : B, Id : 2, Age : 21
===========================

Process finished with exit code 0
```

## 桶排序、计数排序、基数排序的介绍

1. 非基于比较的排序，与被排序的样本的实际数据状况很有关系，所 以实际中并不经常使用 
2. 时间复杂度 $O(N)$，额外空间复杂度 $O(N) $
3. 稳定的排序

### 补充问题

给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度 $O(N)$，且要求不能用非基于比较的排序。

解题思路：

1. 数组n个，准备n+1个桶。找出数组中的最大值和最小值。如果max=min，返回0。

2. 如果max 不等于 min。最小值放在最小桶，最大值放在最大桶里面。

   ![](https://gitee.com/nateshao/images/raw/master/img/20210922213958.png)

```java
package com.nateshao.basic_class_01;

import java.util.Arrays;

public class Code_11_MaxGap {

	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length; // 长度为数组长度
		int min = Integer.MAX_VALUE; // 最小值为系统的最大值
		int max = Integer.MIN_VALUE; // 最大值为系统的最小值
		// 遍历找到最小值和最大值
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) { // 一种数的情况
			return 0;
		}
		// 每个桶的三组信息。1，是否进入桶，2，最大值，3，最小值
		boolean[] hasNum = new boolean[len + 1];
		int[] maxs = new int[len + 1];
		int[] mins = new int[len + 1];
		int bid = 0;
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max); //定位一个数， 进去几号桶
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = maxs[0];
		int i = 1;
		for (; i <= len; i++) { // 找到每一个非空桶，用当前的最小-前一个最大
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}

	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}

	// for test
	public static int comparator(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		Arrays.sort(nums);
		int gap = Integer.MIN_VALUE;
		for (int i = 1; i < nums.length; i++) {
			gap = Math.max(nums[i] - nums[i - 1], gap);
		}
		return gap;
	}

	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			if (maxGap(arr1) != comparator(arr2)) {
				succeed = false;
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
	}

}
```





















































